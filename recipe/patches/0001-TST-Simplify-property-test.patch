From c8d6e3a42b6092314f6f11aef27fd607d47b7a33 Mon Sep 17 00:00:00 2001
From: Zac-HD <zac.hatfield.dodds@gmail.com>
Date: Mon, 12 Jul 2021 11:24:06 +1000
Subject: [PATCH] TST: Simplify property test

---
 numpy/core/tests/test_numeric.py | 41 +++++++++++++-------------------
 1 file changed, 16 insertions(+), 25 deletions(-)

diff --git a/numpy/core/tests/test_numeric.py b/numpy/core/tests/test_numeric.py
index f5113150e..fbcd1d9ff 100644
--- a/numpy/core/tests/test_numeric.py
+++ b/numpy/core/tests/test_numeric.py
@@ -2318,8 +2318,14 @@ def test_NaT_propagation(self, arr, amin, amax):
         actual = np.clip(arr, amin, amax)
         assert_equal(actual, expected)
 
-    @given(data=st.data(), shape=hynp.array_shapes())
-    def test_clip_property(self, data, shape):
+    @given(
+        data=st.data(),
+        arr=hynp.arrays(
+            dtype=hynp.integer_dtypes() | hynp.floating_dtypes(),
+            shape=hynp.array_shapes()
+        )
+    )
+    def test_clip_property(self, data, arr):
         """A property-based test using Hypothesis.
 
         This aims for maximum generality: it could in principle generate *any*
@@ -2335,44 +2341,29 @@ def test_clip_property(self, data, shape):
         That accounts for most of the function; the actual test is just three
         lines to calculate and compare actual vs expected results!
         """
-        # Our base array and bounds should not need to be of the same type as
-        # long as they are all compatible - so we allow any int or float type.
-        dtype_strategy = hynp.integer_dtypes() | hynp.floating_dtypes()
-
-        # The following line is a total hack to disable the varied-dtypes
-        # component of this test, because result != expected if dtypes can vary.
-        dtype_strategy = st.just(data.draw(dtype_strategy))
-
-        # Generate an arbitrary array of the chosen shape and dtype
-        # This is the value that we clip.
-        arr = data.draw(hynp.arrays(dtype=dtype_strategy, shape=shape))
-
         # Generate shapes for the bounds which can be broadcast with each other
         # and with the base shape.  Below, we might decide to use scalar bounds,
         # but it's clearer to generate these shapes unconditionally in advance.
         in_shapes, result_shape = data.draw(
             hynp.mutually_broadcastable_shapes(
                 num_shapes=2,
-                base_shape=shape,
+                base_shape=arr.shape,
                 # Commenting out the min_dims line allows zero-dimensional arrays,
                 # and zero-dimensional arrays containing NaN make the test fail.
                 min_dims=1
-  
             )
         )
+        # This test can fail if we allow either bound to be a scalar `nan`, or
+        # if bounds are of a different (still integer or float) dtype than the 
+        # array.  At some point we should investigate and fix those problems.
         amin = data.draw(
-            dtype_strategy.flatmap(hynp.from_dtype)
-            | hynp.arrays(dtype=dtype_strategy, shape=in_shapes[0])
+            hynp.from_dtype(arr.dtype, allow_nan=False)
+            | hynp.arrays(dtype=arr.dtype, shape=in_shapes[0])
         )
         amax = data.draw(
-            dtype_strategy.flatmap(hynp.from_dtype)
-            | hynp.arrays(dtype=dtype_strategy, shape=in_shapes[1])
+            hynp.from_dtype(arr.dtype, allow_nan=False)
+            | hynp.arrays(dtype=arr.dtype, shape=in_shapes[1])
         )
-        # If we allow either bound to be a scalar `nan`, the test will fail -
-        # so we just "assume" that away (if it is, this raises a special
-        # exception and Hypothesis will try again with different inputs)
-        assume(not np.isscalar(amin) or not np.isnan(amin))
-        assume(not np.isscalar(amax) or not np.isnan(amax))
 
         # Then calculate our result and expected result and check that they're
         # equal!  See gh-12519 for discussion deciding on this property.
-- 
2.31.1.windows.1

